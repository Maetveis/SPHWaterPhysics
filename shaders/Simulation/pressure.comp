#version 450

//Max particles in grid cell is 64
layout(local_size_x = 64) in;

layout(std430) restrict readonly buffer positionBuffer
{
    vec3 position[];
};

layout(std430) restrict writeonly buffer pressureBuffer
{
	float pressure[];
};

layout(std430) restrict readonly buffer gridBuffer
{
	uint gridOffset[];
};

const uint numGridCells = 16;
const uint numGridCellsCubed = numGridCells * numGridCells * numGridCells;//gl_NumWorkGroups.x * gl_NumWorkGroups.y * gl_NumWorkGroups.z;
const uint numParticles = 0x40000;

layout(location = 0) uniform float smoothingLength;
layout(location = 1) uniform float stiffness;
layout(location = 2) uniform float restDensity;

shared vec3 sharedPosition[27 * 64];

struct gridCell
{
	uint globalOffset;
	uint localOffset;
	uint len;
};

shared gridCell gridIndex[3][3][3];

shared uint particleCount;

void loadPositions()
{
	for(int x = 0; x < 3; ++x)
	{
		for(int y = 0; y < 3; ++y)
		{
			for(int z = 0; z < 3; ++z)
			{
				if(gl_LocalInvocationIndex < gridIndex[x][y][z].len)
					sharedPosition[gridIndex[x][y][z].localOffset + gl_LocalInvocationIndex] = position[gridIndex[x][y][z].globalOffset + gl_LocalInvocationIndex];
			}
		}
	}

}

float kernel(const in float r2)
{
	//Poly6 kernel
    float base = (smoothingLength * smoothingLength - r2);
	return 4 * base * base * base / pow(smoothingLength, 1) / 3.14115 ;
}

void updatePressure()
{
    if(gl_LocalInvocationIndex >= gridIndex[1][1][1].len)
	   return;

	vec3 selfpos = sharedPosition[gridIndex[1][1][1].localOffset + gl_LocalInvocationIndex];
	float density = 0;
	for(uint index = 0; index < particleCount; ++index)
	{
		vec3 deltaPos = sharedPosition[index] - selfpos;
		float r2 = dot(deltaPos, deltaPos);
		if(r2 < smoothingLength * smoothingLength)
		{
			density += kernel(r2);
		}
	}

	pressure[gridIndex[1][1][1].globalOffset + gl_LocalInvocationIndex] = stiffness * density;
}

void calculateGridIndices()
{
	uint localOffset = 0;

	for(int x = 0; x < 3; ++x)
	{
		for(int y = 0; y < 3; ++y)
		{
			for(int z = 0; z < 3; ++z)
			{
                if( any(lessThan(gl_WorkGroupID + uvec3(x, y, z), uvec3(1))) || any(lessThan(uvec3(numGridCells + 1), gl_WorkGroupID + uvec3(x, y, z))) )
                {
                    gridIndex[x][y][z].len = 0;
                    continue;
                }

                uint globalOffset =
                    gl_WorkGroupID.x * numGridCells * numGridCells +
                    gl_WorkGroupID.y * numGridCells +
                    gl_WorkGroupID.z;

				if(globalOffset < numGridCellsCubed - 1)
                {
                    gridIndex[x][y][z].globalOffset = gridOffset[globalOffset];
                    gridIndex[x][y][z].len = gridOffset[globalOffset + 1] - gridIndex[x][y][z].globalOffset;
                    gridIndex[x][y][z].localOffset = localOffset;
                }
				else if (globalOffset < numGridCellsCubed)
                {
                    gridIndex[x][y][z].globalOffset = gridOffset[globalOffset];
                    gridIndex[x][y][z].len = numParticles - gridIndex[x][y][z].globalOffset;
                    gridIndex[x][y][z].localOffset = localOffset;
                }
				else
                {
                    gridIndex[x][y][z].len = 0;
                }

				localOffset += gridIndex[x][y][z].len;
			}
		}
	}

	particleCount = localOffset;
}

void main()
{
	if(gl_LocalInvocationIndex == 0)
	{
        particleCount = 0;
		calculateGridIndices();
	}

	barrier();
    memoryBarrierShared();

	loadPositions();

	barrier();
    memoryBarrierShared();

	updatePressure();
}
